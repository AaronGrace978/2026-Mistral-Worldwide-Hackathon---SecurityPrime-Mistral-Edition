// Cyber Security Prime - Vulnerability Scanner Module
// Performs real system checks: firewall, open ports, password policy, defender, etc.

use crate::utils::{generate_id, Severity};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::process::Command;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityScan {
    pub id: String,
    pub status: String,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub vulnerabilities_found: u32,
    pub items_scanned: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub cve_id: Option<String>,
    pub title: String,
    pub description: String,
    pub severity: Severity,
    pub affected_software: String,
    pub current_version: String,
    pub fixed_version: Option<String>,
    pub detected_at: DateTime<Utc>,
    pub status: String,
    pub remediation: String,
}

/// Start a vulnerability scan — runs all checks synchronously
pub fn start_scan() -> Result<VulnerabilityScan, String> {
    let started = Utc::now();
    let vulns = run_all_checks();
    let completed = Utc::now();

    Ok(VulnerabilityScan {
        id: generate_id(),
        status: "completed".to_string(),
        started_at: started,
        completed_at: Some(completed),
        vulnerabilities_found: vulns.len() as u32,
        items_scanned: 7,
    })
}

/// Get all detected vulnerabilities (runs checks fresh each call)
pub fn get_vulnerabilities() -> Result<Vec<Vulnerability>, String> {
    Ok(run_all_checks())
}

// ============================================================================
// Real System Checks
// ============================================================================

fn run_all_checks() -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    check_firewall(&mut vulns);
    check_open_ports(&mut vulns);
    check_password_policy(&mut vulns);
    check_guest_account(&mut vulns);
    check_remote_desktop(&mut vulns);
    check_windows_defender(&mut vulns);
    check_directory_permissions(&mut vulns);

    vulns
}

fn check_firewall(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("netsh")
        .args(["advfirewall", "show", "currentprofile", "state"])
        .output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout).to_lowercase();
        if stdout.contains("off") {
            vulns.push(Vulnerability {
                id: generate_id(),
                cve_id: None,
                title: "Windows Firewall Disabled".to_string(),
                description: "The Windows Firewall for the current network profile is disabled, \
                    leaving the system exposed to network-based attacks."
                    .to_string(),
                severity: Severity::Critical,
                affected_software: "Windows Firewall".to_string(),
                current_version: "Disabled".to_string(),
                fixed_version: None,
                detected_at: Utc::now(),
                status: "open".to_string(),
                remediation: "Enable Windows Firewall: Settings > Privacy & Security > \
                    Windows Security > Firewall & network protection."
                    .to_string(),
            });
        }
    }
}

fn check_open_ports(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("netstat").args(["-an"]).output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout);

        let risky_ports: &[(u16, &str, Severity)] = &[
            (21, "FTP", Severity::High),
            (23, "Telnet", Severity::Critical),
            (445, "SMB / File Sharing", Severity::High),
            (3389, "Remote Desktop (RDP)", Severity::High),
            (5900, "VNC Remote Access", Severity::High),
            (1433, "Microsoft SQL Server", Severity::Medium),
            (3306, "MySQL Database", Severity::Medium),
            (5432, "PostgreSQL Database", Severity::Medium),
        ];

        for (port, service, severity) in risky_ports {
            let suffix = format!(":{}", port);
            let found = stdout.lines().any(|line| {
                let trimmed = line.trim();
                if !trimmed.contains("LISTENING") {
                    return false;
                }
                let parts: Vec<&str> = trimmed.split_whitespace().collect();
                parts.len() >= 2 && parts[1].ends_with(&suffix)
            });

            if found {
                vulns.push(Vulnerability {
                    id: generate_id(),
                    cve_id: None,
                    title: format!("{} Port {} Open", service, port),
                    description: format!(
                        "Port {} ({}) is open and listening for connections. \
                         This service may expose the system to remote attacks if not properly secured.",
                        port, service
                    ),
                    severity: severity.clone(),
                    affected_software: format!("{} Service", service),
                    current_version: format!("Port {}", port),
                    fixed_version: None,
                    detected_at: Utc::now(),
                    status: "open".to_string(),
                    remediation: format!(
                        "Disable the {} service if not needed, or ensure it is properly \
                         secured with authentication and encryption.",
                        service
                    ),
                });
            }
        }
    }
}

fn check_password_policy(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("net").args(["accounts"]).output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout);

        for line in stdout.lines() {
            let lower = line.to_lowercase();

            if lower.contains("minimum password length") {
                if let Some(val) = extract_trailing_number(line) {
                    if val < 8 {
                        vulns.push(Vulnerability {
                            id: generate_id(),
                            cve_id: None,
                            title: "Weak Minimum Password Length".to_string(),
                            description: format!(
                                "Minimum password length is {} characters, below the \
                                 recommended 8-character minimum.",
                                val
                            ),
                            severity: Severity::Medium,
                            affected_software: "Windows Password Policy".to_string(),
                            current_version: format!("{} characters", val),
                            fixed_version: Some("8+ characters".to_string()),
                            detected_at: Utc::now(),
                            status: "open".to_string(),
                            remediation: "Set minimum password length to at least 8 via \
                                Local Security Policy > Account Policies > Password Policy."
                                .to_string(),
                        });
                    }
                }
            }

            if lower.contains("lockout threshold") {
                if let Some(val) = extract_trailing_number(line) {
                    if val == 0 {
                        vulns.push(Vulnerability {
                            id: generate_id(),
                            cve_id: None,
                            title: "No Account Lockout Policy".to_string(),
                            description: "Account lockout threshold is 0 (never lock out), \
                                allowing unlimited password guessing attempts."
                                .to_string(),
                            severity: Severity::Medium,
                            affected_software: "Windows Account Policy".to_string(),
                            current_version: "No lockout".to_string(),
                            fixed_version: Some("5–10 attempts".to_string()),
                            detected_at: Utc::now(),
                            status: "open".to_string(),
                            remediation: "Set lockout threshold to 5–10 attempts via \
                                Local Security Policy > Account Policies > Account Lockout Policy."
                                .to_string(),
                        });
                    }
                }
            }
        }
    }
}

fn check_guest_account(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("net").args(["user", "guest"]).output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout).to_lowercase();
        if stdout.contains("account active") && stdout.contains("yes") {
            vulns.push(Vulnerability {
                id: generate_id(),
                cve_id: None,
                title: "Guest Account Enabled".to_string(),
                description: "The built-in Guest account is enabled, allowing \
                    unauthenticated access to the system."
                    .to_string(),
                severity: Severity::High,
                affected_software: "Windows User Accounts".to_string(),
                current_version: "Active".to_string(),
                fixed_version: Some("Disabled".to_string()),
                detected_at: Utc::now(),
                status: "open".to_string(),
                remediation: "Disable the Guest account: run 'net user guest /active:no' \
                    in an elevated command prompt."
                    .to_string(),
            });
        }
    }
}

fn check_remote_desktop(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("reg")
        .args([
            "query",
            "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server",
            "/v",
            "fDenyTSConnections",
        ])
        .output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout);
        if stdout.contains("0x0") {
            vulns.push(Vulnerability {
                id: generate_id(),
                cve_id: None,
                title: "Remote Desktop Protocol (RDP) Enabled".to_string(),
                description: "Remote Desktop is enabled. RDP is a common attack vector \
                    for ransomware and unauthorized access."
                    .to_string(),
                severity: Severity::Medium,
                affected_software: "Remote Desktop Services".to_string(),
                current_version: "Enabled".to_string(),
                fixed_version: Some("Disabled if not needed".to_string()),
                detected_at: Utc::now(),
                status: "open".to_string(),
                remediation: "Disable Remote Desktop if not needed: Settings > System > \
                    Remote Desktop > Off. If needed, enable Network Level Authentication."
                    .to_string(),
            });
        }
    }
}

fn check_windows_defender(vulns: &mut Vec<Vulnerability>) {
    let output = Command::new("reg")
        .args([
            "query",
            "HKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Real-Time Protection",
            "/v",
            "DisableRealtimeMonitoring",
        ])
        .output();

    if let Ok(out) = output {
        let stdout = String::from_utf8_lossy(&out.stdout);
        if stdout.contains("0x1") {
            vulns.push(Vulnerability {
                id: generate_id(),
                cve_id: None,
                title: "Windows Defender Real-Time Protection Disabled".to_string(),
                description: "Real-time malware protection is disabled, leaving the \
                    system vulnerable to malware infections."
                    .to_string(),
                severity: Severity::Critical,
                affected_software: "Windows Defender".to_string(),
                current_version: "Disabled".to_string(),
                fixed_version: Some("Enabled".to_string()),
                detected_at: Utc::now(),
                status: "open".to_string(),
                remediation: "Enable real-time protection: Settings > Privacy & Security > \
                    Windows Security > Virus & threat protection > Real-time protection."
                    .to_string(),
            });
        }
    }
}

fn check_directory_permissions(vulns: &mut Vec<Vulnerability>) {
    let sensitive = [
        ("C:\\Windows\\System32", "System32 Directory"),
        ("C:\\Windows", "Windows Directory"),
    ];

    for (dir_path, name) in &sensitive {
        let path = std::path::Path::new(dir_path);
        if !path.exists() {
            continue;
        }

        let test_file = path.join(".security_prime_write_test");
        match std::fs::File::create(&test_file) {
            Ok(_) => {
                let _ = std::fs::remove_file(&test_file);
                vulns.push(Vulnerability {
                    id: generate_id(),
                    cve_id: None,
                    title: format!("{} Has Weak Permissions", name),
                    description: format!(
                        "The {} ({}) is writable by the current user, which could \
                         allow malware to modify critical system files.",
                        name, dir_path
                    ),
                    severity: Severity::High,
                    affected_software: "Windows File System".to_string(),
                    current_version: "Writable".to_string(),
                    fixed_version: Some("Read-only for standard users".to_string()),
                    detected_at: Utc::now(),
                    status: "open".to_string(),
                    remediation: format!(
                        "Review and restrict write permissions on {}. \
                         Only administrators should have write access.",
                        dir_path
                    ),
                });
            }
            Err(_) => { /* permission denied — expected secure state */ }
        }
    }
}

fn extract_trailing_number(line: &str) -> Option<u32> {
    line.split_whitespace()
        .rev()
        .find_map(|word| word.parse::<u32>().ok())
}
